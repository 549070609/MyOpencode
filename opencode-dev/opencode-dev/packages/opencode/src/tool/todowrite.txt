使用此工具为当前编码会话创建和管理结构化任务列表。这有助于您跟踪进度、组织复杂任务，并向用户展示您的细致。
它还帮助用户了解任务进度和请求的整体进展。

## 何时使用此工具
在以下场景中主动使用此工具：

1. 复杂的多步骤任务 - 当任务需要 3 个或更多不同的步骤或操作时
2. 非平凡的复杂任务 - 需要仔细规划或多项操作的任务
3. 用户明确请求待办列表 - 当用户直接要求您使用待办列表时
4. 用户提供多个任务 - 当用户提供要完成的事项列表（编号或逗号分隔）时
5. 收到新指令后 - 立即将用户需求记录为待办事项。根据新信息随时编辑待办列表。
6. 完成任务后 - 标记为完成并添加任何新的后续任务
7. 当您开始处理新任务时，将待办标记为 in_progress。理想情况下，一次只应有一个待办处于 in_progress 状态。在开始新任务之前完成现有任务。

## 何时不使用此工具

在以下情况跳过使用此工具：
1. 只有一个简单直接的任务
2. 任务很简单，跟踪它没有组织上的好处
3. 任务可以在少于 3 个简单步骤内完成
4. 任务纯粹是对话性或信息性的

注意：如果只有一个简单任务要做，您不应该使用此工具。在这种情况下，直接执行任务会更好。

## 使用待办列表的示例

<example>
用户：我想在应用程序设置中添加一个深色模式切换。完成后确保运行测试和构建！
助手：我将帮助您在应用程序设置中添加深色模式切换。让我创建一个待办列表来跟踪此实现。
*创建包含以下项目的待办列表：*
1. 在设置页面创建深色模式切换组件
2. 添加深色模式状态管理（context/store）
3. 实现深色主题的 CSS-in-JS 样式
4. 更新现有组件以支持主题切换
5. 运行测试和构建过程，解决出现的任何失败或错误
*开始处理第一个任务*

<reasoning>
助手使用待办列表因为：
1. 添加深色模式是一个多步骤功能，需要 UI、状态管理和样式更改
2. 用户明确要求之后运行测试和构建
3. 助手通过添加"确保测试和构建成功"作为最终任务来推断测试和构建需要通过
</reasoning>
</example>

<example>
用户：帮我在整个项目中将函数 getCwd 重命名为 getCurrentWorkingDirectory
助手：让我先搜索您的代码库，找到所有 'getCwd' 的出现位置。
*使用 grep 或搜索工具定位代码库中 getCwd 的所有实例*
助手：我在 8 个不同的文件中找到了 15 个 'getCwd' 实例。让我创建一个待办列表来跟踪这些更改。
*为需要更新的每个文件创建具体项目的待办列表*

<reasoning>
助手使用待办列表因为：
1. 首先，助手搜索以了解任务的范围
2. 在发现多个文件中有多处出现后，确定这是一个多步骤的复杂任务
3. 待办列表有助于确保每个实例都被系统地跟踪和更新
4. 这种方法可以防止遗漏任何出现位置并保持代码一致性
</reasoning>
</example>


<example>
用户：我需要为我的电子商务网站实现这些功能：用户注册、产品目录、购物车和结账流程。
助手：我将帮助实现这些功能。首先，让我们将所有功能添加到待办列表中。
*根据项目架构创建将每个功能分解为具体任务的待办列表*
助手：让我们从用户注册开始。这将涉及创建数据库模型、API 端点和与您现有身份验证系统集成的前端表单。

<reasoning>
助手使用待办列表因为：
1. 用户以逗号分隔的列表提供了多个复杂功能要实现
2. 待办列表有助于将这些大型功能组织成可管理的任务
3. 这种方法允许跟踪整个实现的进度
</reasoning>
</example>

<example>
用户：你能帮我优化 React 应用程序吗？它渲染很慢，有性能问题。</user>
助手：我将帮助优化您的 React 应用程序。首先，让我检查您的代码库以识别潜在的性能瓶颈。
*审查组件结构、渲染模式、状态管理和数据获取*
助手：分析您的代码库后，我发现了几个性能问题。让我创建一个待办列表来跟踪我们的优化工作。
*创建待办列表，包含：1）为 ProductList 中的昂贵计算实现记忆化，2）为 Dashboard 中的长列表添加虚拟化，3）优化 Gallery 组件中的图片加载，4）修复 ShoppingCart 中的状态更新循环，5）审查包大小并实现代码分割*
让我们从为 ProductList 组件中的昂贵计算实现记忆化开始。</assistant>

<reasoning>
助手使用待办列表因为：
1. 首先，助手检查代码库以识别具体的性能问题
2. 基于此分析，它发现了多个优化机会
3. 性能优化是一个需要多个步骤的非平凡任务
4. 待办列表有助于系统地跟踪不同组件的改进
5. 这种系统方法确保所有性能瓶颈都得到解决
</reasoning>
</example>

## 不使用待办列表的示例

<example>
用户：如何在 Python 中打印 'Hello World'？
助手：在 Python 中，您可以用这段简单的代码打印 "Hello World"：

python
print("Hello World")

执行时，这将在控制台输出文本 "Hello World"。</assistant>

<reasoning>
助手没有使用待办列表，因为这是一个可以一步完成的简单任务。对于如此直接的请求，无需跟踪多个任务或步骤。
</reasoning>
</example>

<example>
用户：git status 命令是做什么的？
助手：git status 命令显示工作目录和暂存区的当前状态。它显示哪些更改已被暂存、哪些没有，以及哪些文件没有被 Git 跟踪。这是在提交之前了解仓库当前状态的基本命令。

<reasoning>
助手没有使用待办列表，因为这是一个没有实际编码任务要完成的信息请求。用户只是在询问解释，而不是让助手执行多个步骤或任务。
</reasoning>
</example>

<example>
用户：你能给 calculateTotal 函数添加一个注释来解释它的作用吗？
助手：好的，让我给 calculateTotal 函数添加一个注释来解释它的作用。
*使用编辑工具给 calculateTotal 函数添加注释*

<reasoning>
助手没有使用待办列表，因为这是一个局限于代码中单一位置的简单直接任务。添加注释不需要跟踪多个步骤或系统组织。
</reasoning>
</example>

<example>
用户：帮我运行 npm install 并告诉我发生了什么。
助手：我将为您运行 npm install 命令。

*执行：npm install*

命令成功完成。以下是输出：
[npm install 命令的输出]

所有依赖项已根据您的 package.json 文件安装完成。

<reasoning>
助手没有使用待办列表，因为这是一个有即时结果的单一命令执行。没有多个步骤要跟踪或组织，使待办列表对这个直接任务来说是不必要的。
</reasoning>
</example>

## 任务状态和管理

1. **任务状态**：使用这些状态跟踪进度：
   - pending：任务尚未开始
   - in_progress：当前正在处理（一次只限一个任务）
   - completed：任务成功完成
   - cancelled：任务不再需要

2. **任务管理**：
   - 工作时实时更新任务状态
   - 完成后立即标记任务为完成（不要批量完成）
   - 任何时候只有一个任务处于 in_progress 状态
   - 在开始新任务之前完成当前任务
   - 取消变得无关的任务

3. **任务分解**：
   - 创建具体、可操作的项目
   - 将复杂任务分解为更小、可管理的步骤
   - 使用清晰、描述性的任务名称

如有疑问，请使用此工具。主动进行任务管理展示了细心，并确保您成功完成所有需求。

