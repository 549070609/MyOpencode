# 内置命令模板

## 用途说明

本文档包含 Oh-My-OpenCode 的内置斜杠命令模板，这些是复杂的工作流程定义。

---

## 一、智能重构命令 (`/refactor`)

**文件位置**: `features/builtin-commands/templates/refactor.ts`

执行智能、确定性的重构，具有完整的代码库感知能力。

### 命令用法

```
/refactor <重构目标> [--scope=<file|module|project>] [--strategy=<safe|aggressive>]

参数：
  重构目标：要重构的内容。可以是：
    - 文件路径：src/auth/handler.ts
    - 符号名称："AuthService 类"
    - 模式："所有使用已弃用 API 的函数"
    - 描述："将验证逻辑提取到单独的模块"

选项：
  --scope：重构范围（默认：module）
    - file：仅单个文件
    - module：模块/目录范围
    - project：整个代码库

  --strategy：风险容忍度（默认：safe）
    - safe：保守，需要最大测试覆盖率
    - aggressive：允许更广泛的更改，需要适当覆盖
```

### 6 阶段工作流程

#### 阶段 0：意图验证（强制第一步）

在任何操作之前，分类和验证请求。

| 信号 | 分类 | 操作 |
|------|------|------|
| 特定文件/符号 | 明确 | 继续代码库分析 |
| "重构 X 为 Y" | 清晰转换 | 继续代码库分析 |
| "改进"、"清理" | 开放式 | **必须询问**："什么具体改进？" |
| 范围模糊 | 不确定 | **必须询问**："哪些模块/文件？" |
| 缺少上下文 | 不完整 | **必须询问**："期望的结果是什么？" |

```
我想确保我正确理解了重构目标。

**我理解的内容**：[解释]
**我不确定的内容**：[具体歧义]

我看到的选项：
1. [选项 A] - [影响]
2. [选项 B] - [影响]

**我的建议**：[带理由的建议]

我应该继续 [建议]，还是你更喜欢不同的？
```

#### 阶段 1：代码库分析（并行探索）

同时启动多个探索代理：

```
// 代理 1：查找重构目标
call_omo_agent(subagent_type="explore", run_in_background=true,
  prompt="查找 [目标] 的所有出现和定义。报告：文件路径、行号、使用模式。")

// 代理 2：查找相关代码
call_omo_agent(subagent_type="explore", run_in_background=true,
  prompt="查找所有导入、使用或依赖 [目标] 的代码。报告：依赖链、导入图。")

// 代理 3：查找相似模式
call_omo_agent(subagent_type="explore", run_in_background=true,
  prompt="在代码库中查找与 [目标] 相似的代码模式。报告：类似实现、既定惯例。")

// 代理 4：查找测试
call_omo_agent(subagent_type="explore", run_in_background=true,
  prompt="查找与 [目标] 相关的所有测试文件。报告：测试文件路径、测试用例名称。")

// 代理 5：架构上下文
call_omo_agent(subagent_type="explore", run_in_background=true,
  prompt="查找 [目标] 周围的架构模式和模块组织。报告：模块边界、层结构。")
```

同时使用直接工具：
```typescript
// LSP 工具用于精确分析
lsp_hover(filePath, line, character)           // 类型信息、文档
lsp_goto_definition(filePath, line, character) // 定义位置
lsp_find_references(filePath, line, character) // 所有使用位置
lsp_document_symbols(filePath)                 // 文件结构
lsp_diagnostics(filePath)                      // 现有错误

// AST-Grep 用于模式分析
ast_grep_search(pattern, lang, paths)
ast_grep_replace(pattern, rewrite, lang, dryRun=true)  // 始终先预览
```

#### 阶段 2：构建代码地图

```markdown
## 代码地图：[目标]

### 核心文件（直接影响）
- `path/to/file.ts:L10-L50` - 主要定义
- `path/to/file2.ts:L25` - 关键使用

### 依赖图
[目标] 
├── 导入自：
│   ├── module-a (类型)
│   └── module-b (工具)
├── 被导入于：
│   ├── consumer-1.ts
│   └── consumer-2.ts
└── 被使用于：
    ├── handler.ts (直接调用)
    └── service.ts (依赖注入)

### 影响区域
| 区域 | 风险级别 | 受影响文件 | 测试覆盖率 |
|------|----------|------------|------------|
| 核心 | 高 | 3 个文件 | 85% |
| 消费者 | 中 | 8 个文件 | 70% |
| 边缘 | 低 | 2 个文件 | 50% |
```

#### 阶段 3：测试评估

```markdown
## 验证计划

### 测试命令
- 单元测试：`bun test` / `npm test` / `pytest` / 等
- 集成测试：[命令如果存在]
- 类型检查：`tsc --noEmit` / `pyright` / 等

### 验证检查点
每个重构步骤后：
1. lsp_diagnostics → 无新错误
2. 运行测试命令 → 全部通过
3. 类型检查 → 干净
```

| 覆盖率级别 | 策略 |
|------------|------|
| 高 (>80%) | 每步后运行现有测试 |
| 中 (50-80%) | 运行测试 + 添加安全断言 |
| 低 (<50%) | **暂停**：建议先添加测试 |
| 无 | **阻止**：拒绝激进重构 |

#### 阶段 4：计划生成

调用 Plan 代理创建详细重构计划：

```
Task(subagent_type="plan", prompt="创建详细重构计划：
  ## 重构目标
  [用户的原始请求]

  ## 代码地图
  [插入代码地图]

  ## 测试覆盖率
  [插入验证计划]

  ## 约束
  - 必须遵循现有模式
  - 每步后必须运行测试
  
  ## 要求
  1. 分解为原子重构步骤
  2. 每步必须可独立验证
  3. 按依赖顺序排列步骤
  4. 为每步指定确切文件和行范围
  5. 包含每步的回滚策略")
```

#### 阶段 5：执行重构

对每个步骤：

```typescript
// 执行前
// 1. 标记步骤待办为 in_progress
// 2. 读取当前文件状态
// 3. 验证 lsp_diagnostics 为基线

// 执行符号重命名
lsp_prepare_rename(filePath, line, character)  // 验证可重命名
lsp_rename(filePath, line, character, newName) // 执行重命名

// 或模式转换
ast_grep_replace(pattern, rewrite, lang, dryRun=true)   // 先预览
ast_grep_replace(pattern, rewrite, lang, dryRun=false)  // 执行

// 执行后验证（强制）
lsp_diagnostics(filePath)  // 必须干净
bash("bun test")           // 测试必须通过
bash("tsc --noEmit")       // 类型检查必须通过
```

#### 阶段 6：最终验证

```bash
# 完整测试套件
bun test

# 完整类型检查
tsc --noEmit

# Lint 检查
eslint .

# 构建验证
bun run build
```

### 关键规则

**永远不要做：**
- 更改后跳过 lsp_diagnostics 检查
- 在测试失败时继续
- 不理解影响就进行更改
- 使用 `as any`、`@ts-ignore`、`@ts-expect-error`
- 删除测试以使其通过
- 提交损坏的代码

**始终做：**
- 更改前理解
- 应用前预览 (ast_grep dryRun=true)
- 每次更改后验证
- 遵循现有代码库模式
- 实时更新待办事项
- 在逻辑检查点提交

---

## 二、深度初始化命令 (`/init-deep`)

**文件位置**: `features/builtin-commands/templates/init-deep.ts`

生成分层的 AGENTS.md 文件，根据复杂度评分决定位置。

### 命令用法

```
/init-deep                      # 更新模式：修改现有 + 在需要时创建新的
/init-deep --create-new         # 读取现有 → 删除所有 → 从头重新生成
/init-deep --max-depth=2        # 限制目录深度（默认：3）
```

### 4 阶段工作流程

#### 阶段 1：发现 + 分析（并发）

立即启动后台探索代理：

```
background_task(agent="explore", prompt="项目结构：预测检测到的语言的标准模式 → 仅报告偏差")
background_task(agent="explore", prompt="入口点：查找主文件 → 报告非标准组织")
background_task(agent="explore", prompt="惯例：查找配置文件 → 报告项目特定规则")
background_task(agent="explore", prompt="反模式：查找 'DO NOT'、'NEVER'、'ALWAYS' 注释 → 列出禁止的模式")
background_task(agent="explore", prompt="构建/CI：查找工作流、Makefile → 报告非标准模式")
background_task(agent="explore", prompt="测试模式：查找测试配置、测试结构 → 报告独特惯例")
```

**动态代理生成**：根据项目规模生成额外代理

| 因素 | 阈值 | 额外代理 |
|------|------|----------|
| 总文件数 | >100 | 每 100 文件 +1 |
| 总行数 | >10k | 每 10k 行 +1 |
| 目录深度 | ≥4 | +2 用于深度探索 |
| 大文件 (>500 行) | >10 文件 | +1 用于复杂度热点 |
| Monorepo | 检测到 | 每个包/工作区 +1 |
| 多语言 | >1 | 每种语言 +1 |

同时执行：
- Bash 结构分析
- 读取现有 AGENTS.md
- LSP 代码地图（如可用）

#### 阶段 2：评分和位置决策

| 因素 | 权重 | 高阈值 | 来源 |
|------|------|--------|------|
| 文件数量 | 3x | >20 | bash |
| 子目录数量 | 2x | >5 | bash |
| 代码比例 | 2x | >70% | bash |
| 独特模式 | 1x | 有自己的配置 | explore |
| 模块边界 | 2x | 有 index.ts/__init__.py | bash |
| 符号密度 | 2x | >30 个符号 | LSP |
| 导出数量 | 2x | >10 个导出 | LSP |
| 引用中心性 | 3x | >20 个引用 | LSP |

| 分数 | 操作 |
|------|------|
| **根目录 (.)** | 始终创建 |
| **>15** | 创建 AGENTS.md |
| **8-15** | 如果是独立领域则创建 |
| **<8** | 跳过（父目录覆盖） |

#### 阶段 3：生成 AGENTS.md

**根目录 AGENTS.md 模板：**

```markdown
# 项目知识库

**生成时间**：{TIMESTAMP}
**提交**：{SHORT_SHA}
**分支**：{BRANCH}

## 概述
{1-2 句话：什么 + 核心技术栈}

## 结构
{root}/
├── {dir}/    # {仅非显而易见的用途}
└── {entry}

## 查找位置
| 任务 | 位置 | 备注 |

## 代码地图
| 符号 | 类型 | 位置 | 引用 | 角色 |

## 惯例
{仅偏离标准的内容}

## 反模式（本项目）
{这里明确禁止的}

## 独特风格
{项目特定}

## 命令
{dev/test/build}

## 备注
{陷阱}
```

**质量门槛**：50-150 行，无通用建议，无显而易见的信息。

**子目录 AGENTS.md**：并行启动 document-writer 代理生成，30-80 行，永不重复父内容。

#### 阶段 4：审查和去重

- 删除通用建议
- 删除父目录重复内容
- 修剪到大小限制
- 验证电报式风格

### 最终报告

```
=== init-deep 完成 ===

模式：{update | create-new}

文件：
  ✓ ./AGENTS.md (根, {N} 行)
  ✓ ./src/hooks/AGENTS.md ({N} 行)

分析的目录：{N}
创建的 AGENTS.md：{N}
更新的 AGENTS.md：{N}
```

### 反模式

- **静态代理数量**：必须根据项目大小/深度变化代理数量
- **顺序执行**：必须并行（explore + LSP 并发）
- **忽略现有**：始终首先读取现有内容，即使使用 --create-new
- **过度文档化**：不是每个目录都需要 AGENTS.md
- **冗余**：子目录永不重复父目录
- **通用内容**：删除任何适用于所有项目的内容
- **冗长风格**：电报式或死亡

---

## 命令工具使用哲学

### LSP 工具
- **更改前理解**：`lsp_hover`、`lsp_goto_definition` 掌握上下文
- **影响分析**：`lsp_find_references` 在修改前映射所有使用
- **安全重构**：`lsp_prepare_rename` → `lsp_rename` 用于符号重命名
- **持续验证**：每次更改后 `lsp_diagnostics`

### AST-Grep
用于结构转换。**关键**：始终先 `dryRun=true`，审查，然后执行。

### 代理
- `explore`：并行代码库模式发现
- `plan`：详细重构计划生成
- `oracle`：复杂架构决策咨询
- `librarian`：遇到弃用方法时主动使用，查询官方文档
- `document-writer`：生成 AGENTS.md 文件

